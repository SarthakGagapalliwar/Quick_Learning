Username Availability & Lookup Techniques
When a user enters a username, the system needs to quickly determine:
Is this username already taken?
If yes, suggest similar available usernames.

Different data structures and algorithms help here:

1. Redis HashMap – Exact Match Lookup

Stores usernames as key → value pairs.
Very fast lookups: O(1) average time.
If the username exists → return cache-hit.
✅ Great for direct exact match checks.
❌ Not efficient for prefix search or suggesting similar usernames.


Trie (Prefix Tree) – Autocomplete & Prefix Search

Stores usernames character by character in a tree.
Lookup time: O(m) (where m = length of username).
✅ Perfect for:
Checking if a username exists.
Finding all usernames starting with a prefix.
Autocomplete / suggestion systems.
Uses more memory, but can be optimized with compressed tries (radix trees).



B+ Tree – Large-Scale Ordered Storage

Lookup time: O(log N) (where N = number of usernames).
✅ Supports:
Exact match searches.
Range queries (e.g., list usernames alphabetically).
Widely used in databases (SQL, MongoDB, FoundationDB).
More scalable than tries when dealing with very large datasets.



Bloom Filter – Super-Fast Existence Check

A bit array + multiple hash functions.
Can tell if a username might exist:
If filter says not present → definitely not in DB.
If filter says present → check actual DB/Redis to confirm.
✅ Extremely fast, memory-efficient.
❌ Allows false positives, but never false negatives.
Ideal for large-scale systems where checking billions of usernames is needed.



Practical Approach

Step 1: Use a Bloom Filter for ultra-fast rejection of non-existent usernames.
Step 2: If Bloom Filter says exists, verify using Redis HashMap (exact lookup).
Step 3: If taken, use Trie or B+ Tree for:
Autocomplete → suggest similar usernames.
Prefix search → find available variations.



In short:

Redis HashMap → Exact yes/no check.
Trie → Prefix & autocomplete.
B+ Tree → Large-scale ordered lookups.
Bloom Filter → Fast rejection at scale.