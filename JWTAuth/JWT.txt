** Stateful Authentication using JWT **

When the browser sends a login request, the server first verifies whether the user exists in the database.
If the user is valid, the server creates a session and sends back a cookie containing the session ID.

On subsequent requests (for example, when the browser requests the userâ€™s profile), the browser automatically includes the session ID cookie.
The server then checks if this session ID exists and is valid in its database.
If the session is valid, the server authorizes the request and returns the userâ€™s profile data.

Problems with Stateful Authentication

1.Server Restart Issue:
If the server restarts, all session IDs stored in memory are lost, causing all users to be logged out.

2.Load Balancer Complexity (Sticky Sessions):
In a load-balanced environment, maintaining sticky sessions (ensuring a user always connects to the same server)
increases complexity and reduces scalability.

3.Centralized Session Store Requirement:
To avoid sticky sessions, a shared or centralized session store (like Redis or a database) must be 
maintained for all servers â€” which adds additional overhead and management complexity.




** Stateless Authentication using JWT **

In this approach, when the browser sends a login request, the server verifies the userâ€™s credentials.
If the credentials are valid, the server generates a JWT (JSON Web Token) that is digitally signed using a cryptographic key.
This token is then sent to the browser, usually stored in cookies or local storage.

When the browser makes further requests (for example, to view the profile page), it includes the JWT in the request headers or cookies.
The server then verifies the tokenâ€™s signature using the same secret key.
If the token is valid, the server processes the request and returns the requested data, such as the userâ€™s profile.

ðŸŸ¢ Note: In this method, nothing is stored on the server.
All the session information is stored within the JWT on the browser side, making the system completely stateless.


Advantages of Stateless JWT Authentication

1.No Server-Side Storage:
The server doesnâ€™t need to maintain session data. All user information is encoded inside the JWT, making the system stateless.

2.Easier Scalability:
Since no session data is stored on the server, multiple servers can handle requests independently â€” ideal for load-balanced or distributed systems.

3.Faster Authentication:
Each request can be verified quickly using the JWT signature without querying a session database.

4.Cross-Domain Support:
JWTs can be easily used across different domains or microservices, making them suitable for modern, distributed applications.

5.Reduced Server Load:
Since session management is eliminated, server memory and storage requirements are lower.



What is JSON Web Token (JWT)?

A JSON Web Token (JWT) is a compact, secure, and URL-safe way of transmitting information between a client and a server.
It is commonly used for authentication and authorization in modern web applications.

A JWT is a digitally signed token that ensures the data inside it has not been tampered with.
It is usually signed using a secret key (HMAC) or a public/private key pair (RSA or ECDSA).

Structure of a JWT
A JWT consists of three parts, separated by dots (.):
Header â€“ Contains metadata about the token, such as the type of token (JWT) and the signing algorithm used (e.g., HS256).
Payload â€“ Contains user data or claims (e.g., user_id, email, role).
Signature â€“ Created by encoding the header and payload and signing them with a secret key to ensure the tokenâ€™s integrity.


JWT Signature
The header and payload are first Base64URL-encoded.
Then, a cryptographic signing algorithm (like HMAC SHA256, RSA, or ECDSA) is applied using a secret key or private key.
This produces the signature, which ensures data integrity and authenticity: if anyone modifies the header or payload, the signature will no longer match.

Key points:
The signature does not encrypt the payload â€” anyone can still decode the header and payload, since they are only Base64URL-encoded.
The signature cannot be forged without the secret key, which prevents tampering.
So, itâ€™s a form of digital signing, not encryption.


The output of a JWT is three Base64URL-encoded strings, separated by dots (.):
This format makes JWTs compact and easy to transmit through HTML and HTTP environments (such as in URLs, headers, or cookies).


/*
| **Aspect**        | **Encoding**                                                                 | **Encryption**                                                                 |
| ----------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **Purpose**       | To transform data into a different format for safe transmission or storage.  | To protect data confidentiality by making it unreadable to unauthorized users. |
| **Goal**          | Ensure data can be **safely transferred** or **read by compatible systems**. | Ensure data can **only be read by the intended recipient**.                    |
| **Reversibility** | **Easily reversible** â€” anyone who knows the encoding format can decode it.  | **Reversible only with a key** â€” requires a secret or private key to decrypt.  |
| **Security**      | Provides **no security** â€” just changes data format.                         | Provides **strong security** â€” protects data from unauthorized access.         |
| **Example**       | Base64, URL encoding, ASCII encoding.                                        | AES, RSA, DES, etc.                                                            |
| **Used in JWT?**  | JWT **uses encoding (Base64URL)** for readability and transport.             | JWT **can also use encryption (JWE)** for securing sensitive data.             |


In the context of JWT, the tokenâ€™s parts (header, payload, and signature) are Base64URL-encoded,
which makes them easy to send through HTTP but not secure by itself. For higher security, JWT can also be encrypted (JWE) 
to protect the payload data from being read by anyone other than the intended recipient.
*/



What Happens if a JWT is Stolen?
If a JWT is stolen (for example, via XSS, network interception, or another vulnerability),
an attacker can use it to impersonate the user until the token expires.

To mitigate this risk, JWTs often include an expiration time (exp claim):

The token is valid only for a limited duration.
After it expires, the user must re-authenticate to get a new token.

User Experience Challenge

If the expiration time is too short, the user will have to log in frequently, which can be frustrating.
If itâ€™s too long, a stolen token can be misused for a longer period, increasing security risk.

**Important**

Common Solution: Refresh Tokens
To balance security and user experience:

Issue a short-lived access token (the JWT used for requests).
Issue a long-lived refresh token (kept securely, e.g., HTTP-only cookie).

When the access token expires, the client automatically uses the refresh token to get a new 
access token without forcing the user to log in again.

âœ… This way, even if an access token is stolen, itâ€™s only usable for a short time, 
while the user still enjoys a smooth login experience.



Refresh Token in JWT Authentication
A refresh token is a long-lived token issued alongside a short-lived access token (the regular JWT). 
Its main purpose is to obtain a new access token when the old one expires, 
without requiring the user to log in again.
Access Token: Short-lived (e.g., 5â€“15 minutes), used for authenticating API requests.
Refresh Token: Long-lived (e.g., days or weeks), stored securely (usually in an HTTP-only cookie) and used only to request new access tokens.

Benefits:
Limits the impact if the access token is stolen, because it expires quickly.
Improves user experience, as users donâ€™t have to log in repeatedly.
Keeps the system secure while maintaining usability.

we store refresh token in database 

Storing Refresh Tokens and Rotation
To improve security, refresh tokens can be stored in the server database. This allows the server to:
Verify the refresh token when the client requests a new access token.

Rotate tokens: when the access token expires, the client sends the refresh token to the server. The server:
Issues a new access token
Issues a new refresh token (invalidating the old one)

This process is called refresh token rotation.

Benefits:
If a refresh token is stolen, it can only be used once before it is invalidated.
Reduces the risk of long-lived token misuse.
Improves overall security while maintaining a smooth user experience, since users rarely have to log in manually.

âœ… Tip: Always store refresh tokens securely in the database and mark them as revoked after rotation to prevent reuse by attackers.




seesrion is Stateful ;

Stateful Session Authentication

In stateful authentication, the server maintains session information for each user.
When a user logs in, the server verifies the credentials against the database.
If the user is valid, the server creates a session and generates a session ID.
The session ID is sent to the browser, usually stored in cookies.
The server also stores this session ID in the database or server memory.

Whenever the browser makes a request (e.g., to access a protected resource), it sends the session ID along with the request.
The server then checks the session ID against its store to validate the session before responding.

âœ… Key point: Every request requires a database or session store lookup, which ensures the user is authenticated but adds server overhead.